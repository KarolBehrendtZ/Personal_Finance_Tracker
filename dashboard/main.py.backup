import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import requests
import os
from datetime import datetime, timedelta
from typing import Dict, List

# Page configuration
st.set_page_config(
    page_title="Personal Finance Tracker",
    page_icon="üí∞",
    layout="wide",
    initial_sidebar_state="expanded"
)

# API configuration
API_URL = os.getenv('API_URL', 'http://localhost:8080/api/v1')

# Authentication state
if 'token' not in st.session_state:
    st.session_state.token = None
if 'user' not in st.session_state:
    st.session_state.user = None

def make_api_request(endpoint: str, method: str = 'GET', data: Dict = None):
    """Make authenticated API request"""
    headers = {}
    if st.session_state.token:
        headers['Authorization'] = f'Bearer {st.session_state.token}'
    
    url = f"{API_URL}{endpoint}"
    
    try:
        if method == 'GET':
            response = requests.get(url, headers=headers)
        elif method == 'POST':
            response = requests.post(url, json=data, headers=headers)
        elif method == 'PUT':
            response = requests.put(url, json=data, headers=headers)
        elif method == 'DELETE':
            response = requests.delete(url, headers=headers)
        
        if response.status_code == 401:
            # Only show session expired error if user was logged in and it's not a login/register request
            if st.session_state.token and not endpoint.startswith('/auth/'):
                st.session_state.token = None
                st.session_state.user = None
                st.error("Session expired. Please log in again.")
            return None
        
        if response.status_code == 400:
            # Handle validation errors
            try:
                error_data = response.json()
                if 'error' in error_data:
                    # Don't show error here - let the calling function handle it
                    pass
            except:
                pass
            return None
        
        response.raise_for_status()
        return response.json()
    except requests.exceptions.ConnectionError:
        st.error("‚ùå Cannot connect to server. Please check if the API is running.")
        return None
    except requests.exceptions.Timeout:
        st.error("‚ùå Request timed out. Please try again.")
        return None
    except requests.exceptions.RequestException as e:
        # Only show generic error if it's not an auth endpoint
        if not endpoint.startswith('/auth/'):
            st.error(f"API Error: {e}")
        return None

def login_page():
    """Login/Register page"""
    st.title("üè¶ Personal Finance Tracker")
    
    tab1, tab2 = st.tabs(["Login", "Register"])
    
    with tab1:
        st.subheader("Login")
        with st.form("login_form"):
            email = st.text_input("Email")
            password = st.text_input("Password", type="password")
            submitted = st.form_submit_button("Login")
            
            if submitted:
                if not email or not password:
                    st.error("Please fill in all fields!")
                else:
                    data = {"email": email, "password": password}
                    response = make_api_request("/auth/login", "POST", data)
                    
                    if response:
                        st.session_state.token = response['token']
                        st.session_state.user = response['user']
                        st.success("Logged in successfully!")
                        # Clear any error messages and force refresh
                        if 'error_message' in st.session_state:
                            del st.session_state.error_message
                        # Use experimental_rerun if rerun doesn't work
                        try:
                            st.rerun()
                        except AttributeError:
                            st.experimental_rerun()
                    else:
                        st.error("‚ùå Invalid email or password. Please try again.")
    
    with tab2:
        st.subheader("Register")
        with st.form("register_form"):
            first_name = st.text_input("First Name")
            last_name = st.text_input("Last Name")
            email = st.text_input("Email")
            password = st.text_input("Password", type="password")
            confirm_password = st.text_input("Confirm Password", type="password")
            submitted = st.form_submit_button("Register")
            
            if submitted:
                if not all([first_name, last_name, email, password, confirm_password]):
                    st.error("Please fill in all fields!")
                elif password != confirm_password:
                    st.error("Passwords don't match!")
                elif len(password) < 6:
                    st.error("Password must be at least 6 characters long!")
                else:
                    data = {
                        "first_name": first_name,
                        "last_name": last_name,
                        "email": email,
                        "password": password
                    }
                    response = make_api_request("/auth/register", "POST", data)
                    
                    if response:
                        st.session_state.token = response['token']
                        st.session_state.user = response['user']
                        st.success("Registered successfully!")
                        # Clear any error messages and force refresh
                        if 'error_message' in st.session_state:
                            del st.session_state.error_message
                        # Use experimental_rerun if rerun doesn't work
                        try:
                            st.rerun()
                        except AttributeError:
                            st.experimental_rerun()
                    else:
                        st.error("‚ùå Registration failed. Email might already be taken or there was a server error.")

def get_analytics_summary(start_date: str = None, end_date: str = None) -> Dict:
    """Get analytics summary from API"""
    params = {}
    if start_date:
        params['start_date'] = start_date
    if end_date:
        params['end_date'] = end_date
    
    endpoint = "/analytics/summary"
    if params:
        query_string = "&".join([f"{k}={v}" for k, v in params.items()])
        endpoint += f"?{query_string}"
    
    return make_api_request(endpoint)

def get_spending_analytics(start_date: str = None, end_date: str = None) -> List[Dict]:
    """Get spending analytics from API"""
    params = {}
    if start_date:
        params['start_date'] = start_date
    if end_date:
        params['end_date'] = end_date
    
    endpoint = "/analytics/spending"
    if params:
        query_string = "&".join([f"{k}={v}" for k, v in params.items()])
        endpoint += f"?{query_string}"
    
    result = make_api_request(endpoint)
    return result if result else []

def get_transactions_from_api(limit: int = 10) -> List[Dict]:
    """Get transactions from API"""
    endpoint = f"/transactions?limit={limit}"
    result = make_api_request(endpoint)
    return result if result else []

def dashboard_page():
    """Main dashboard page"""
    st.title("üí∞ Personal Finance Dashboard")
    
    # Sidebar
    with st.sidebar:
        st.write(f"Welcome, {st.session_state.user['first_name']}!")
        
        if st.button("Logout"):
            # Clear all session state
            st.session_state.token = None
            st.session_state.user = None
            # Clear any cached data
            st.cache_data.clear()
            st.cache_resource.clear()
            # Force immediate rerun to show login page
            try:
                st.rerun()
            except AttributeError:
                st.experimental_rerun()
        
        st.divider()
        
        # Date range selector
        date_range = st.date_input(
            "Select Date Range",
            value=[datetime.now() - timedelta(days=30), datetime.now()],
            max_value=datetime.now()
        )
    
    # Main navigation tabs
    tab1, tab2, tab3 = st.tabs(["üìä Overview", "üìà Spending Trends", "üí≥ Transactions"])
    
    with tab1:
        show_overview_tab(date_range)
    
    with tab2:
        show_spending_trends_tab()
        
    with tab3:
        show_transactions_tab(date_range)

def show_overview_tab(date_range):
    """Show overview dashboard"""
    user_id = st.session_state.user['id']
    
    # Overview metrics
    col1, col2, col3, col4 = st.columns(4)
    
    if len(date_range) == 2:
        # Use API to get analytics summary
        summary_data = get_analytics_summary(
            start_date=date_range[0].strftime('%Y-%m-%d'),
            end_date=date_range[1].strftime('%Y-%m-%d')
        )
        
        if summary_data:
            total_income = summary_data.get('total_income', 0)
            total_expenses = summary_data.get('total_expenses', 0)
            net_income = summary_data.get('net_income', 0)
            account_balance = summary_data.get('account_balance', 0)
            
            col1.metric("Total Income", f"${total_income:,.2f}")
            col2.metric("Total Expenses", f"${total_expenses:,.2f}")
            col3.metric("Net Income", f"${net_income:,.2f}", delta=f"{net_income:,.2f}")
            col4.metric("Account Balance", f"${account_balance:,.2f}")
    
    # Charts
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Spending by Category")
        
        if len(date_range) == 2:
            spending_data = get_spending_analytics(
                start_date=date_range[0].strftime('%Y-%m-%d'),
                end_date=date_range[1].strftime('%Y-%m-%d')
            )
            
            if spending_data and len(spending_data) > 0:
                df_spending = pd.DataFrame(spending_data)
                
                # Create pie chart
                fig = px.pie(
                    df_spending, 
                    values='amount', 
                    names='category_name',
                    title="Spending Distribution"
                )
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No spending data available for the selected period.")
        else:
            st.info("Please select a date range.")
    
    with col2:
        st.subheader("Expense Trends")
        
        if len(date_range) == 2:
            spending_data = get_spending_analytics(
                start_date=date_range[0].strftime('%Y-%m-%d'),
                end_date=date_range[1].strftime('%Y-%m-%d')
            )
            
            if spending_data and len(spending_data) > 0:
                df_spending = pd.DataFrame(spending_data)
                
                # Create bar chart
                fig = px.bar(
                    df_spending, 
                    x='category_name', 
                    y='amount',
                    title="Spending by Category"
                )
                fig.update_xaxes(tickangle=45)
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No spending data available for the selected period.")
        else:
            st.info("Please select a date range.")

def show_spending_trends_tab():
    """Show spending trends with predictions"""
    st.subheader("üìà Daily Spending Trends & Predictions")
    
    # Period selector
    col1, col2 = st.columns([1, 2])
    
    with col1:
        period = st.selectbox(
            "Time Period",
            options=["day", "week", "month"],
            index=1,  # default to week
            format_func=lambda x: x.title()
        )
    
    with col2:
        # Date selector based on period
        if period == "day":
            selected_date = st.date_input("Select Day", value=datetime.now().date())
            date_str = selected_date.strftime('%Y-%m-%d')
        elif period == "week":
            selected_date = st.date_input("Select Week (any day in the week)", value=datetime.now().date())
            date_str = selected_date.strftime('%Y-%m-%d')
        else:  # month
            col_month, col_year = st.columns(2)
            with col_month:
                month = st.selectbox("Month", range(1, 13), index=datetime.now().month - 1,
                                   format_func=lambda x: datetime(2024, x, 1).strftime('%B'))
            with col_year:
                year = st.selectbox("Year", range(2020, 2030), index=datetime.now().year - 2020)
            date_str = f"{year}-{month:02d}-01"
    
    # Get trends data
    trends_data = get_spending_trends(period, date_str)
    
    if trends_data and 'trends' in trends_data:
        trends = trends_data['trends']
        
        if trends:
            # Create DataFrame
            df = pd.DataFrame(trends)
            
            # Display summary
            st.info(f"Showing trends for {period} of {trends_data['date']}")
            
            # Create the main trends table
            st.subheader("Spending Trends Table")
            
            # Format the data for display
            display_df = df.copy()
            display_df['current_spend'] = display_df['current_spend'].apply(lambda x: f"${x:,.2f}")
            display_df['predicted_spend'] = display_df['predicted_spend'].apply(lambda x: f"${x:,.2f}")
            display_df['change_percent'] = display_df['change_percent'].apply(lambda x: f"{x:+.1f}%")
            
            # Add trend indicators
            trend_indicators = {
                'up': 'üìà ‚ÜóÔ∏è',
                'down': 'üìâ ‚ÜòÔ∏è', 
                'stable': '‚û°Ô∏è',
                'new': 'üÜï'
            }
            display_df['trend'] = display_df['trend_direction'].map(trend_indicators)
            
            # Reorder and rename columns
            display_df = display_df[['category_name', 'current_spend', 'predicted_spend', 'change_percent', 'trend']]
            display_df.columns = ['Category', f'Current {period.title()}', f'Predicted Next {period.title()}', 'Change %', 'Trend']
            
            # Display table with styling
            st.dataframe(
                display_df,
                use_container_width=True,
                hide_index=True
            )
            
            # Visualizations
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Current vs Predicted Spending")
                
                # Create comparison chart
                chart_df = df[['category_name', 'current_spend', 'predicted_spend']].head(10)
                
                fig = go.Figure(data=[
                    go.Bar(name=f'Current {period.title()}', x=chart_df['category_name'], y=chart_df['current_spend']),
                    go.Bar(name=f'Predicted Next {period.title()}', x=chart_df['category_name'], y=chart_df['predicted_spend'])
                ])
                
                fig.update_layout(
                    barmode='group',
                    title=f"Spending Comparison - Top 10 Categories",
                    xaxis_tickangle=-45
                )
                
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.subheader("Trend Direction Distribution")
                
                # Count trends
                trend_counts = df['trend_direction'].value_counts()
                
                fig = px.pie(
                    values=trend_counts.values,
                    names=trend_counts.index,
                    title="Distribution of Spending Trends"
                )
                
                st.plotly_chart(fig, use_container_width=True)
            
            # Insights section
            st.subheader("üí° Insights")
            
            # Calculate insights
            total_current = df['current_spend'].sum()
            total_predicted = df['predicted_spend'].sum()
            change = ((total_predicted - total_current) / total_current * 100) if total_current > 0 else 0
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric(
                    f"Total Current {period.title()}", 
                    f"${total_current:,.2f}"
                )
            
            with col2:
                st.metric(
                    f"Predicted Next {period.title()}", 
                    f"${total_predicted:,.2f}",
                    delta=f"{change:+.1f}%"
                )
                
            with col3:
                trending_up = len(df[df['trend_direction'] == 'up'])
                trending_down = len(df[df['trend_direction'] == 'down'])
                
                if trending_up > trending_down:
                    trend_summary = "üìà Mostly Increasing"
                elif trending_down > trending_up:
                    trend_summary = "üìâ Mostly Decreasing"
                else:
                    trend_summary = "‚û°Ô∏è Mixed Trends"
                
                st.metric("Overall Trend", trend_summary)
            
            # Top categories insights
            if not df.empty:
                biggest_increase = df.loc[df['change_percent'].idxmax()]
                biggest_decrease = df.loc[df['change_percent'].idxmin()]
                
                st.markdown("### üîç Key Changes")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    if biggest_increase['change_percent'] > 0:
                        st.success(f"üìà **Biggest Increase**: {biggest_increase['category_name']} (+{biggest_increase['change_percent']:.1f}%)")
                    
                with col2:
                    if biggest_decrease['change_percent'] < 0:
                        st.error(f"üìâ **Biggest Decrease**: {biggest_decrease['category_name']} ({biggest_decrease['change_percent']:.1f}%)")
        
        else:
            st.info("No spending trends data available for the selected period.")
    else:
        st.error("Failed to load spending trends data.")

def show_transactions_tab(date_range):
    """Show transactions list"""
    st.subheader("üí≥ Recent Transactions")
    
    if len(date_range) == 2:
        transactions = get_transactions_from_api(
            start_date=date_range[0].strftime('%Y-%m-%d'),
            end_date=date_range[1].strftime('%Y-%m-%d')
        )
        
        if transactions and len(transactions) > 0:
            df_transactions = pd.DataFrame(transactions)
            
            # Format the data
            df_transactions['amount'] = df_transactions['amount'].apply(lambda x: f"${x:.2f}")
            df_transactions['date'] = pd.to_datetime(df_transactions['date']).dt.strftime('%Y-%m-%d')
            
            # Display table
            st.dataframe(
                df_transactions[['date', 'description', 'amount', 'type']],
                use_container_width=True,
                hide_index=True
            )
        else:
            st.info("No transactions found.")
    else:
        st.info("No transactions found.")

def get_spending_trends(period: str, date: str):
    """Get spending trends from API"""
    endpoint = f"/analytics/trends?period={period}&date={date}"
    return make_api_request(endpoint)
            # Use API to get spending analytics
            spending_data = get_spending_analytics(
                start_date=date_range[0].strftime('%Y-%m-%d'),
                end_date=date_range[1].strftime('%Y-%m-%d')
            )
            
            if spending_data:
                # Convert to DataFrame for plotting
                category_df = pd.DataFrame(spending_data)
                if not category_df.empty and 'amount' in category_df.columns:
                    # Filter out zero amounts
                    category_df = category_df[category_df['amount'] > 0]
                    if not category_df.empty:
                        fig = px.pie(category_df, values='amount', names='category_name',
                                   title="Spending by Category")
                        st.plotly_chart(fig, use_container_width=True)
                    else:
                        st.info("No expense data available for the selected period.")
                else:
                    st.info("No expense data available for the selected period.")
            else:
                st.info("No expense data available for the selected period.")
    
    with col2:
        st.subheader("Daily Spending Trend")
        st.info("Daily spending trend feature coming soon!")
    
    # Recent transactions
    st.subheader("Recent Transactions")
    
    # Get recent transactions from API
    transactions_data = get_transactions_from_api(limit=10)
    
    if transactions_data:
        # Convert to DataFrame for display
        transactions_df = pd.DataFrame(transactions_data)
        
        if not transactions_df.empty:
            # Format the dataframe for display
            if 'amount' in transactions_df.columns:
                transactions_df['amount'] = transactions_df['amount'].apply(lambda x: f"${x:,.2f}")
            
            # Select and rename columns for display
            display_columns = {}
            if 'date' in transactions_df.columns:
                display_columns['date'] = 'Date'
            if 'description' in transactions_df.columns:
                display_columns['description'] = 'Description'
            if 'amount' in transactions_df.columns:
                display_columns['amount'] = 'Amount'
            if 'type' in transactions_df.columns:
                display_columns['type'] = 'Type'
            
            st.dataframe(
                transactions_df,
                column_config=display_columns,
                hide_index=True,
                use_container_width=True
            )
        else:
            st.info("No transactions found.")
    else:
        st.info("No transactions found.")

def main():
    """Main application"""
    if st.session_state.token is None:
        login_page()
    else:
        dashboard_page()

if __name__ == "__main__":
    main()
